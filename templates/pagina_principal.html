<html>
    <head>
        <title>Tur</title>

        <link rel="icon" href="{{ url_for('static', filename='media/logo.png') }}">

        <script language="javascript" type="text/javascript"  src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
        <script language="javascript" type="text/javascript" src="{{ url_for('static', filename='scripts/arbor.js') }}"></script>
        <script language="javascript" type="text/javascript" src="{{ url_for('static', filename='scripts/graphics.js') }}"></script>
        <script language="javascript" type="text/javascript" src="{{ url_for('static', filename='scripts/renderer.js') }}"></script>
        <script language="javascript" type="text/javascript" src="{{ url_for('static', filename='scripts/arbor-tweens.js') }}"></script>
    </head>
    <body>
      <canvas id="viewport" width="800" height="600"></canvas>
      
      <script language="javascript" type="text/javascript">

            function construcaoGrafo(matrizDistancias){
                for (let i = 1; i <= matrizDistancias.length; i++){
                    let color = (i - 1 == 0 ? "#009c3b" : "#002776")
                    sys.addNode(
                        "No_" + (i - 1), {label: "Local nº: " + i.toString(), color: color, shape: "circle", "fixed": true}
                    )
                }

                for (let i = 1; i <= matrizDistancias.length; i++){
                    for (let j = 1; j <= matrizDistancias.length; j++){
                        sys.addEdge("No_" + (i - 1), "No_" + (j - 1), {length: .75, color: "black"})
                    }
                }
            }

            function sleep(ms) {
                return new Promise(
                    resolve => setTimeout(resolve, ms)
                );
            }

            async function HeldKarp(matrizDistancias, conjuntosSubgrafos){
                var numeroNos = matrizDistancias.length

                let custoPercursoSubgrafos = {}

                for (let i = 1; i < numeroNos; i++){
                    // Trabalha com os subgrafos do primeiro nó
                    // Os subgrafos que incluem o nó inicial são os subgrafos de primeiro deslocamento
                    // Conjunto de subgrafos de primeiro deslocamento: [[nó inicial, vizinho 1], [nó inicial, vizinho 2], ...]
                    // Por causa do nó inicial, os subgrafos de primeiro deslocamento só possuem um sentido: nó inicial -> vizinho

                    // Os subgrafos de primeiro deslocamento só possuem um deslocamento possível, esse é o deslocamento de menor custo do subgrafo

                    // Coleta as distâncias dos primeiros deslocamentos possíveis
                    custoPercursoSubgrafos[[1 << i, i]] = [
                        matrizDistancias[0][i], 0
                    ]

                    // Visualização
                    await sleep(200)
                    
                    let no = sys.getNode("No_" + i)
                    sys.tweenNode(no, 0.1, {color: "#ffdf00"})
                
                    await sleep(200)
                
                    sys.tweenNode(no, 0.1, {color: "#002776"})

                    // custoPercursoSubgrafos[bits, destino] = [distância, origem] 
                    // Obs.: A distância inclui o caminho percorrido até a origem - distância percorrida
                    // Obs.: Os bits identificam o subgrafo do deslocamento
                }

                // Percorre conjuntos de subgrafos
                for (let i = 2; i < numeroNos; i++){
                    // Conjunto de subgrafos de mesmo tamanho
                    let conjuntoSubgrafos = conjuntosSubgrafos[i - 2]
                    let numeroSubgrafosConjunto = conjuntoSubgrafos.length
                    
                    // Percorre sugrafos do conjunto
                    for (let j = 0; j < numeroSubgrafosConjunto; j++){
                        let subgrafo = conjuntoSubgrafos[j]
                        let tamanhoSubgrafo = subgrafo.length

                        let bits = 0

                        // Percorrer subgrafo - gerar bits para os subgrafos
                        for (let k = 0; k < tamanhoSubgrafo; k++){
                            bits = bits | 1 << subgrafo[k]

                            // Os componentes de um subgrafo são distintos e, portanto, geram deslocamentos distintos
                            // A -> B !== B -> A

                            // Então é possível acessar um deslocamento específico usando o seu valor de bits
                            // e o seu valor de origem ou destino
                            
                            // Diferentes subgrafos podem possuir deslocamentos iguais, mas os percursos
                            // anteriores e distância acumulada podem ser diferentes

                            // Visualização
                            await sleep(300)
                    
                            let no = sys.getNode("No_" + subgrafo[k])
                            sys.tweenNode(no, 0.1, {color: "#00FFFF"})
                
                            await sleep(300)
                
                            sys.tweenNode(no, 0.1, {color: "#002776"})
                        }

                        // Percorrer subgrafo - coletar opções de deslocamento
                        for (let k = 0; k < tamanhoSubgrafo; k++){
                            // Recuperação do bits que identifica um subgrafo do conjunto anterior de subgrafos
                            let prev = bits & ~(1 << subgrafo[k])

                            // subgrafo[l] = no origem
                            // subgrafo[k] = no destino

                            // O subgrafo[k], na operação acima, garante que o bits recuperado identifique um subgrafo
                            // do conjunto de subgrafos anterior ao atual que possua deslocamento para o subgrafo[l] e 
                            // não possua deslocamento para o subgrafo[k]

                            let opcoesDeslocamento = []

                            // Percorrer subgrafo
                            // Encontra a opção de deslocamento com menor custo para o destino subgrafo[k]
                            for (var l = 0; l < tamanhoSubgrafo; l++){
                                if (subgrafo[l] === 0 || subgrafo[l] === subgrafo[k]){
                                    continue
                                }
                                
                                // O índice é utilizado para acessar o custo acumulado do deslocamento do nó inicial 
                                // até o subgrafo[l] no subgrafo identificado pela variável prev

                                let indice = prev.toString() + "," + subgrafo[l].toString()

                                opcoesDeslocamento.push(
                                    [custoPercursoSubgrafos[indice][0] + matrizDistancias[subgrafo[l]][subgrafo[k]], subgrafo[l]]
                                )

                                // Visualização
                                await sleep(400)         
                    
                                let noOrigem = sys.getNode("No_" + subgrafo[l])
                                let noDestino = sys.getNode("No_" + subgrafo[k])
                                sys.tweenNode(noOrigem, 0.1, {color: "#CF3215"})
                                sys.tweenNode(noDestino, 0.1, {color: "#7821DB"})
        
                                await sleep(400)
        
                                sys.tweenNode(noOrigem, 0.1, {color: "#002776"})
                                sys.tweenNode(noDestino, 0.1, {color: "#002776"})
                            }

                           opcoesDeslocamento.sort(
                               function(a, b){
                                   return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0; 
                               }   
                           )
                           
                           // Somente é salva a opção de deslocamento para o destino subgrafo[k] com menor custo acumulado
                           custoPercursoSubgrafos[[bits, subgrafo[k]]] = opcoesDeslocamento[0]
                        }
                    }
                }

                // Gerar o bits que identifica o último subgrafo
                let bits = 2**numeroNos - 2

                // -2: os bits da primeira locomoção foram calculados separadamente

                // O último conjunto de subgrafos é a ultima combinação, a combinação com maior números de componentes possível
                // O último conjunto de subgrafos só possui um subgrafo, portanto esse bits identifica também o último conjunto de subgrafos

                let opcoesDeslocamentoFinalSalvas = []
                for (let i = 1; i < numeroNos; i++){
                    let indice = bits.toString() + "," + i.toString()
                    opcoesDeslocamentoFinalSalvas.push([custoPercursoSubgrafos[indice][0] + matrizDistancias[i][0], i])
                }

                // Identifica melhor custo de percurso
                opcoesDeslocamentoFinalSalvas.sort(
                    function(a, b){
                        return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0; 
                    }   
                )
                let melhorCustoPercurso = opcoesDeslocamentoFinalSalvas[0][0]
                
                // Destino final do percurso antes do retorno ao ponto inicial
                let destino = opcoesDeslocamentoFinalSalvas[0][1]

                let percursoComMenorCusto = []
                for (let i = 0; i < (numeroNos - 1); i++){
                    // Visualização
                    await sleep(300)
                    
                    let no = sys.getNode("No_" + (destino))
                    sys.tweenNode(no, 0.1, {color: "red"})
        
                    await sleep(300)
        
                    sys.tweenNode(no, 0.1, {color: "#002776"})

                    // Percorrendo percuso de melhor custo em ordem inversa
                    percursoComMenorCusto.push(destino)

                    // Bits que identifica o subgrafo da origem do destino
                    let bits_origem = bits & ~(1 << destino)

                    // Identificando a origem do destino
                    let indice = bits.toString() + "," + destino.toString()    
                    
                    // Transformando a origem do destino em novo destino
                    destino = custoPercursoSubgrafos[indice][1]

                    bits = bits_origem
                }

                percursoComMenorCusto.push(0)
                percursoComMenorCusto.reverse()

                for (let i = 0; i < numeroNos; i++){

                    for (let j = 0; j < numeroNos; j++){
                        if (percursoComMenorCusto[j] !== percursoComMenorCusto[i + 1]){
                            let edge = sys.getEdges("No_" + percursoComMenorCusto[i], "No_" + percursoComMenorCusto[j])[0]
                            sys.pruneEdge(edge)
                        }
                        await sleep(200)
                    }

                    if (i == (numeroNos - 1)){
                        sys.addEdge("No_" + (percursoComMenorCusto[i]), "No_0", {length: .75, color: "black"})
                        await sleep(200)
                    }

                    let no = sys.getNode("No_" + (i))
                    sys.tweenNode(no, 0.1, {color: "#009c3b"})
        
                    await sleep(200)
                }
            }

            var matrizDistancias = {{ matrizDistancias }}
            var conjuntosSubgrafos = {{ conjuntosSubgrafos }}

            var sys = arbor.ParticleSystem(1000, 400, 1);

            sys.parameters({ gravity:true });
            sys.renderer = Renderer("#viewport") ;

            construcaoGrafo(matrizDistancias);
            HeldKarp(matrizDistancias, conjuntosSubgrafos)
      </script>
    </body>
</html>