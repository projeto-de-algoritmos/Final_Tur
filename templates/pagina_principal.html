<html>
    <head>
        <title>Tur</title>

        <script language="javascript" type="text/javascript"  src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
        <script language="javascript" type="text/javascript" src="{{ url_for('static', filename='scripts/arbor.js') }}"></script>
        <script language="javascript" type="text/javascript" src="{{ url_for('static', filename='scripts/graphics.js') }}"></script>
        <script language="javascript" type="text/javascript" src="{{ url_for('static', filename='scripts/renderer.js') }}"></script>
    </head>
    <body>
      <canvas id="viewport" width="800" height="600"></canvas>
      
      <script language="javascript" type="text/javascript">

            function HeldKarp(matrizDistancias, conjuntosSubgrafos){
                var numeroNos = matrizDistancias.length

                let custoPercursoSubgrafos = {}

                for (let i = 1; i < numeroNos; i++){
                    // Trabalha com os subgrafos do primeiro nó
                    // Os subgrafos que incluem o nó inicial são os subgrafos de primeiro deslocamento
                    // Conjunto de subgrafos de primeiro deslocamento: [[nó inicial, vizinho 1], [nó inicial, vizinho 2], ...]
                    // Por causa do nó inicial, os subgrafos de primeiro deslocamento só possuem um sentido: nó inicial -> vizinho

                    // Os subgrafos de primeiro deslocamento só possuem um deslocamento possível, esse é o deslocamento de menor custo do subgrafo

                    // Coleta as distâncias dos primeiros deslocamentos possíveis
                    custoPercursoSubgrafos[[1 << i, i]] = [
                        matrizDistancias[0][i], 0
                    ]
                    
                    // custoPercursoSubgrafos[bits, destino] = [distância, origem] 
                    // Obs.: A distância inclui o caminho percorrido até a origem - distância percorrida
                    // Obs.: Os bits identificam o subgrafo do deslocamento
                }

                // Percorre conjuntos de subgrafos
                for (let i = 2; i < numeroNos; i++){
                    // Conjunto de subgrafos de mesmo tamanho
                    let conjuntoSubgrafos = conjuntosSubgrafos[i-2]
                    let numeroSubgrafosConjunto = conjuntoSubgrafos.length
                    
                    // Percorre sugrafos do conjunto
                    for (let j = 0; j < numeroSubgrafosConjunto; j++){
                        let subgrafo = conjuntoSubgrafos[j]
                        let tamanhoSubgrafo = subgrafo.length

                        let bits = 0

                        // Percorrer subgrafo - gerar bits para os subgrafos
                        for (let k = 0; k < tamanhoSubgrafo; k++){
                            bits = bits | 1 << subgrafo[k]

                            // Os componentes de um subgrafo são distintos e, portanto, geram deslocamentos distintos
                            // A -> B !== B -> A

                            // Então é possível acessar um deslocamento específico usando o seu valor de bits
                            // e o seu valor de origem ou destino
                            
                            // Diferentes subgrafos podem possuir deslocamentos iguais, mas os percursos
                            // anteriores e distância acumulada podem ser diferentes
                        }

                        // Percorrer subgrafo - coletar opções de deslocamento
                        for (let k = 0; k < tamanhoSubgrafo; k++){
                            // Recuperação do bits que identifica um subgrafo do conjunto anterior de subgrafos
                            let prev = bits & ~(1 << subgrafo[k])

                            // subgrafo[l] = no origem
                            // subgrafo[k] = no destino

                            // O subgrafo[k], na operação acima, garante que o bits recuperado identifique um subgrafo
                            // do conjunto de subgrafos anterior ao atual que possua deslocamento para o subgrafo[l] e 
                            // não possua deslocamento para o subgrafo[k]

                            // Exemplo 
                            //  - Subgrafos
                            //      (i, 1, 2, 3) = 1->2; 1->3; 2->1; 2->3; 3->1; 3->2  
                            //      (j, 1, 2, 4) = 1->2; 1->4; 2->1; 2->4; 4->1; 4->2
                            //  - Novo Possível Deslocamento
                            //      (2->3) do subgrafo (k, 1, 2, 3, 4)
                            //      -> O novo possível deslocamento necessita do subgrafo j porque o subgrafo i
                            //         já gerou percursos para até 3 

                            let opcoesDeslocamento = []

                            // Percorrer subgrafo - encontrar opção de deslocamento com menos custo
                            for (var l = 0; l < tamanhoSubgrafo; l++){
                                if (subgrafo[l] === 0 || subgrafo[l] === subgrafo[k]){
                                    continue
                                }
                                
                                // O índice é utilizado para acessar o custo acumulado, desde o nó inicial, do 
                                // deslocamento até o subgrafo[l]
                                
                                // Obs.: do deslocamento até o subgrafo[l] por meio do subgrafo identificado pela variável prev
                                console.log(bits, prev, subgrafo[l], subgrafo[k])
                                let indice = prev.toString() + "," + subgrafo[l].toString()

                                opcoesDeslocamento.push(
                                    [custoPercursoSubgrafos[indice][0] + matrizDistancias[subgrafo[l]][subgrafo[k]], subgrafo[l]]
                                )
                            }

                           opcoesDeslocamento.sort(
                               function(a, b){
                                   return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0; 
                               }   
                           )
                           
                           // Somente é salva a opção de deslocamento do subgrafo com menos custo acumulado
                           // Para o destino k
                           custoPercursoSubgrafos[[bits, subgrafo[k]]] = opcoesDeslocamento[0]
                        }
                    }
                }

                let bits = (2**numeroNos - 1) - 1
                let opcoesDeslocamento = []
                for (let i = 1; i < numeroNos; i++){
                    let indice = bits.toString() + "," + i.toString()
                    opcoesDeslocamento.push([custoPercursoSubgrafos[indice][0] + matrizDistancias[i][0], i])
                }

                opcoesDeslocamento.sort(
                    function(a, b){
                        return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0; 
                    }   
                )
                let opt = opcoesDeslocamento[0][0]
                let parent = opcoesDeslocamento[0][1]

                path = []
                for (i = 0; i < (numeroNos - 1); i++){
                    path.push(parent)
                    new_bits = bits & ~(1 << parent)

                    let indice = bits.toString() + "," + parent.toString()                    
                    parent = custoPercursoSubgrafos[indice][1]

                    bits = new_bits
                }

                path.push(0)

                console.log(opt, path)
            }
            
            var matrizDistancias = {{ matrizDistancias }}
            var conjuntosSubgrafos = {{ conjuntosSubgrafos }}

            var sys = arbor.ParticleSystem(1000, 400, 1);

            sys.parameters({ gravity:true });
            sys.renderer = Renderer("#viewport") ;

            for (let i = 1; i <= matrizDistancias.length; i++){
                node = sys.addNode(
                    "No_" + (i-1), {label: "Local nº: " + i.toString(), color: "blue", shape: 'circle', "fixed": true}
                )
            }

            for (let i = 1; i <= matrizDistancias.length; i++){
                for (let j = 1; j <= matrizDistancias.length; j++){
                    edge = sys.addEdge("No_" + (i-1), "No_" + (j-1), {length:.75, pointSize:3})
                }
            }

            HeldKarp(matrizDistancias, conjuntosSubgrafos)
      </script>
    </body>
</html>